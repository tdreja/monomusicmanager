using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Windows.Forms;

namespace MonoMusicManager
{
    /// <summary>
    /// This class holds all relevant data from a music file (except the file contents itself).
    /// It also has methods for copying. Sorting files is done by the MusicFolder class.
    /// </summary>
    public class MusicFile
    {
        /// <summary>
        /// This regex will match with all characters that are invalid for file names.
        /// It is used to clean up any audio files that have invalid characters in their title
        /// </summary>
        public static Regex pathRegex = new Regex(string.Format("[{0}]", Regex.Escape(new string(Path.GetInvalidFileNameChars()))));

        /// <summary>
        /// To ensure that the collection remains usable on a systems, this regex will match invalid characters in linux systems
        /// </summary>
        public static Regex linuxRegex = new Regex(string.Format("[{0}]", Regex.Escape("\\/:*?\"<>|")));

        /// <summary>
        /// ID3Tag: Artist
        /// </summary>
        public string Artist { get; protected set; }

        /// <summary>
        /// ID3Tag: Title
        /// </summary>
        public string Title { get; protected set; }

        /// <summary>
        /// ID3Tag: Album
        /// </summary>
        public string Album { get; protected set; }

        /// <summary>
        /// ID3Tag: Genre
        /// </summary>
        public string Genre { get; protected set; }

        /// <summary>
        /// File path to the source file loaded into the program
        /// </summary>
        public string Source { get; protected set; }

        /// <summary>
        /// Bitrate of the music file
        /// </summary>
        public int BiteRate { get; protected set; }

        /// <summary>
        /// Duration of the music file
        /// </summary>
        public TimeSpan Duration { get; protected set; }

        /// <summary>
        /// ID3Tag: Track Number
        /// </summary>
        public uint TrackNr { get; protected set; }

        /// <summary>
        /// ID3Tag: Disc Number
        /// </summary>
        public uint DiscNr { get; protected set; }

        /// <summary>
        /// Folder the file will be sorted into
        /// </summary>
        public MusicFolder.Folders Folder { get; internal set; }

        /// <summary>
        /// Parent Folder of the album (if one exists, otherwise null);
        /// Example: ../Albums/*Parent*/AlbumTitle;
        /// This is generated by the internal algorithm that checks with the music collection;
        /// Note: This is useful whenever you injest a collection of one artist or an album series, so they don't clutter the collection.
        /// </summary>
        public string AlbumParentFolder { get; internal set; }

        /// <summary>
        /// Alternate name of the album folder.
        /// Example: 3 different artists in album, so name would be just *album*. Use Alternate *artist1 - album*
        /// </summary>
        public string AlternateAlbumFolder { get; internal set; }

        /// <summary>
        /// Alternate Parent Folder of the album (if one exists, otherwise null);
        /// Example: ../Albums/*Parent*/AlbumTitle;
        /// This one is set by the user within the UI to replace the AlbumParentFolder;
        /// Note: This is useful whenever you injest a collection of one artist or an album series, so they don't clutter the collection.
        /// </summary>
        public string AlternateParentFolder { get; internal set; }

        /// <summary>
        /// Is this part of a mixed album or is there only one artist
        /// </summary>
        public bool HasVariousArtists { get; internal set; }

        /// <summary>
        /// How many discs does the album have?
        /// </summary>
        public uint MaxDiscNr { get; internal set; }

        /// <summary>
        /// How many tracks does the current disc have?
        /// </summary>
        public uint MaxTrackNr { get; internal set; }

        /// <summary>
        /// Creates a new MusicFile by reading the source file at the given path
        /// </summary>
        /// <param name="path">Path of a music file to be injested</param>
        public MusicFile(string path)
        {
            FileInfo info = new System.IO.FileInfo(path);
            Source = info.FullName;
            if(info.Exists)
            {
                TagLib.File file = TagLib.File.Create(this.Source);

                Artist = file.Tag.FirstPerformer;
                Title = file.Tag.Title;
                Album = file.Tag.Album;
                Genre = file.Tag.FirstGenre;
                TrackNr = file.Tag.Track;
                DiscNr = file.Tag.Disc;
                BiteRate = file.Properties.AudioBitrate;
                Duration = file.Properties.Duration;
            }
            else
            {
                Artist = null;
                Title = null;
                Album = null;
                Genre = null;
                TrackNr = 0;
                DiscNr = 0;
                BiteRate = 0;
                Duration = TimeSpan.FromSeconds(0);
            }

            Folder = MusicFolder.Folders.NONE;
            AlbumParentFolder = null;
            AlternateAlbumFolder = null;
            AlternateParentFolder = null;
            HasVariousArtists = false;
            MaxDiscNr = 0;
            MaxTrackNr = 0;
        }

        /// <summary>
        /// Creates a new music file based on the given parameters
        /// </summary>
        /// <param name="artist">ID3Tag Artist</param>
        /// <param name="title">ID3Tag Title</param>
        /// <param name="album">ID3Tag Album</param>
        /// <param name="genre">ID3Tag Genre</param>
        /// <param name="path">Path of the music file</param>
        public MusicFile(string artist, string title, string album, string genre, string path)
        {
            Artist = artist;
            Title = title;
            Album = album;
            Source = path;
            Genre = genre;
            TrackNr = 1;
            DiscNr = 1;
            Folder = MusicFolder.Folders.NONE;
            AlbumParentFolder = null;
            HasVariousArtists = false;
            MaxDiscNr = 0;
            MaxTrackNr = 0;
            BiteRate = 0;
            Duration = TimeSpan.FromSeconds(0);
        }

        public override string ToString()
        {
            return FormatDiscNr() + FormatTrackNr() + " - " + Artist + " - " + Title + " (from '" + Album + "', Genre: " + Genre + ") File: " + Source + " Sorted into: "+MusicFolder.GetFolderName(Folder);
        }

        /// <summary>
        /// Copies the file store at 'Source' to the given target (root-)folder, while maintaining the structure as defined by 'Folder' and the album and artist fields.
        /// This will create all subfolders necessary for the copy process.
        /// </summary>
        /// <param name="targetFolder">Root Folder where the file should be copied to (Usually the music collection folder)</param>
        /// <param name="overrideFile">If the file already exists, should it be overriden?</param>
        /// <returns></returns>
        public string CopyToDestination(string targetFolder, bool overrideFile)
        {
            if(CanCopy())
            {
                FileInfo dest = new FileInfo(GetDestination(targetFolder));
                if(!dest.Directory.Exists)
                {
                    Directory.CreateDirectory(dest.Directory.FullName);
                }

                if(!Source.Equals(dest.FullName))
                {
                    if(!File.Exists(dest.FullName) || overrideFile)
                    {
                        File.Copy(Source, dest.FullName, overrideFile);
                    }
                }

                return dest.FullName;
            }
            else
            {
                return Source;
            }
            
        }

        /// <summary>
        /// Based upon the given root folder, this will create the path of the music file while maintaining the structure as defined by 'Folder' and the album and artist fields.
        /// This will include all necessary subdirectories within the root folder.
        /// </summary>
        /// <param name="targetFolder">Root folder as basis for the path (usually the music collection folder)</param>
        /// <returns>Path of the music file, will all naming options (parent folders, album names etc.) included</returns>
        public string GetDestination(string targetFolder)
        {
            FileInfo sourceFile = new FileInfo(Source);
            string newPath = MusicFolder.GetPath(targetFolder, Folder);
            //Console.WriteLine("Source " + sourceFile + " new " + newPath);

            if (Folder == MusicFolder.Folders.ALBUM || Folder == MusicFolder.Folders.FILMMUSIK 
                || Folder == MusicFolder.Folders.PODCASTS || Folder == MusicFolder.Folders.LIEDER)
            {
                if (HasParent())
                {
                    if(AlternateParentFolder != null)
                    {
                        newPath = Path.Combine(newPath, AlternateParentFolder);
                    }
                    else if(AlbumParentFolder != null)
                    {
                        newPath = Path.Combine(newPath, AlbumParentFolder);
                    }
                }

                //Console.WriteLine("Folder: "+ CreateFolderName() + " File: " + CreateFileName(sourceFile, true));

                //Console.WriteLine("Destination: " + Path.Combine(newPath, CreateFolderName(), CreateFileName(sourceFile, true)));
                return Path.Combine(newPath, CreateFolderName(), CreateFileName(sourceFile, Folder != MusicFolder.Folders.LIEDER));
            }
            else
            {
                //Console.WriteLine("Destination = Source: " + Source);
                return Source;
            }
        }

        /// <summary>
        /// Does this music file actually exist on the hard drive and does it contain the necessary ID3 tags?
        /// </summary>
        /// <returns>True: File exists and has necessary info, False: Not a valid file</returns>
        public bool IsValid()
        {
            return Source != null && Title != null && Title.Length > 0 && Artist != null && Artist.Length > 0;
        }

        /// <summary>
        /// Can the music file be copied into a music collection? Firstly checks whether the file is valid and then whether it was sorted into a correct folder.
        /// </summary>
        /// <returns>True: File fulfills all requirements, False: File cannot be copied</returns>
        public bool CanCopy()
        {
            return IsValid() && Folder != MusicFolder.Folders.NONE && Folder != MusicFolder.Folders.PLAYLISTS;
        }

        /// <summary>
        /// Creates the name of the album folder this file will be placed in (direct parent folder).
        /// If no album is set, the artist will instead be used as parent.
        /// Note: The name has all invalid characters for filepaths removed!
        /// </summary>
        /// <returns>Name of the Parent folder for this music file</returns>
        public string CreateFolderName()
        {
            if (AlternateAlbumFolder != null && AlternateAlbumFolder.Length > 0)
            {
                return linuxRegex.Replace(pathRegex.Replace(AlternateAlbumFolder, ""), "");
            }
            else if (Artist != null)
            {
                if (Folder == MusicFolder.Folders.LIEDER || Album == null || Album.Length == 0)
                {
                    return linuxRegex.Replace(pathRegex.Replace(Artist,""), "");
                }
                else if (HasVariousArtists)
                {
                    return linuxRegex.Replace(pathRegex.Replace(Album, ""), "");
                }
                else
                {
                    return linuxRegex.Replace(pathRegex.Replace(Artist + " - " + Album, ""), "");
                }
            }
            else
            {
                return "";
            }
            
        }

        /// <summary>
        /// Creates the new file name (after our convention) for the source file
        /// Note: The name has all invalid characters for filepaths removed!
        /// </summary>
        /// <param name="sourceFile">Source file to ensure that the correct file extension is used</param>
        /// <param name="useTrackNr">Naming Convention parameter: Do we add a number in front of the title (for albums) or do we just use the title (for singles)</param>
        /// <returns>The new file name (no paths!)</returns>
        private string CreateFileName(FileInfo sourceFile, bool useTrackNr)
        {
            if (useTrackNr && TrackNr > 0)
            {
                return FormatDiscNr() + FormatTrackNr() + " - " + linuxRegex.Replace(pathRegex.Replace(Title, ""),"") + sourceFile.Extension;
            }
            else
            {
                return linuxRegex.Replace(pathRegex.Replace(Title, ""),"") + sourceFile.Extension;
            }
        }

        /// <summary>
        /// Formats the tracknumber to include all necessary leading zeros
        /// </summary>
        /// <returns>String with correctly formatted number</returns>
        public string FormatTrackNr()
        {
            if(MaxTrackNr >= 100)
            {
                return TrackNr.ToString("000");
            }
            else
            {
                return TrackNr.ToString("00");
            }
        }

        /// <summary>
        /// Formats the discnumber with all necessary leading zeros.
        /// Missing disc numbers will be set to 1
        /// </summary>
        /// <returns>String with correctly formatted number</returns>
        public string FormatDiscNr()
        {
            uint disc = Math.Max(1, DiscNr);

            if(MaxDiscNr >= 10)
            {
                return disc.ToString("00");
            }
            else
            {
                return disc.ToString("0");
            }
        }

        /// <summary>
        /// Returns whether this music file has a parent folder above its album folder or not
        /// </summary>
        /// <returns>True: Algorithm found parent or User set parent, False: No parent</returns>
        public bool HasParent()
        {
            return (AlternateParentFolder != null && AlternateParentFolder.Length > 0) ||
                (AlbumParentFolder != null && AlbumParentFolder.Length > 0);
        }

        /// <summary>
        /// Returns the parent folder above the album folder
        /// </summary>
        /// <returns>Parent folder or null if none was set</returns>
        public string GetParent()
        {
            if(AlternateParentFolder != null)
            {
                return AlternateParentFolder;
            }
            return AlbumParentFolder;
        }

        /// <summary>
        /// Returns the album folder this file will be placed in.
        /// If the user set an alternate folder, this will return the alternate
        /// </summary>
        /// <returns>Album folder or null, if the file has no album tag</returns>
        public string GetAlbumFolder()
        {
            if(AlternateAlbumFolder != null)
            {
                return AlternateAlbumFolder;
            }
            return Album;
        }
    }

    #region Folder & AlbumInfo

    /// <summary>
    /// The music collection is split into different subfolders: For albums, playlists, single songs etc.
    /// This class handles sorting music files into this structure
    /// </summary>
    public static class MusicFolder
    {
        /// <summary>
        /// This constant defines how many songs an album must contain to be counted as an album
        /// </summary>
        public const int MINIMUM_ALBUM_SONG_NUMBER = 3;

        /// <summary>
        /// This enum represents the different subfolders the music collection is split into
        /// </summary>
        public enum Folders
        {
            NONE,
            ALBUM,
            LIEDER,
            FILMMUSIK,
            PODCASTS,
            PLAYLISTS
        }

        /// <summary>
        /// Adds the given folder onto the given base path
        /// </summary>
        /// <param name="basePath">Root folder for the music collection</param>
        /// <param name="folder">Folder that is to be added</param>
        /// <returns>New path with the given folder added onto the base</returns>
        public static string GetPath(string basePath, Folders folder)
        {
            return Path.Combine(basePath, GetFolderName(folder));
        }

        /// <summary>
        /// This method assigns actual names to the enum values
        /// </summary>
        /// <param name="folder">Enum value of a subfolder</param>
        /// <returns>Name of a subfolder</returns>
        public static string GetFolderName(Folders folder)
        {
            switch(folder)
            {
                case Folders.ALBUM:
                    return "Album";
                case Folders.LIEDER:
                    return "Lieder";
                case Folders.FILMMUSIK:
                    return "Soundtracks";
                case Folders.PLAYLISTS:
                    return "Playlists";
                case Folders.PODCASTS:
                    return "Podcasts";
                default:
                    return "NoFolder";
            }
        }

        /// <summary>
        /// Returns a list of all subfolder names (not the enum, but the actual string names!)
        /// </summary>
        /// <returns>Returns a list of all subfolder names</returns>
        public static List<string> GetAllFolderNames()
        {
            List<string> names = new List<string>();

            foreach (Folders fold in Enum.GetValues(typeof(Folders))) {
                names.Add(GetFolderName(fold));
            }

            return names;
        }

        /// <summary>
        /// This method receives a file drag, loads all music files from it and (pre-)sorts them into the target path. 
        /// Note: This will not copy the files!
        /// </summary>
        /// <param name="targetPath">Path for the music collection</param>
        /// <param name="dragEvent">Files dragged in by the user</param>
        /// <returns>A list of all (sorted) music files read from the file drag</returns>
        public static List<MusicFile> ReadMusicFiles(string targetPath, DragEventArgs dragEvent)
        {
            return ReadMusicFiles(targetPath, dragEvent.Data.GetData(DataFormats.FileDrop) as string[]);
        }

        /// <summary>
        /// This method receives a list of music files, reads them and (pre-)sorts them into the target path.
        /// Note: This will not copy the files!
        /// </summary>
        /// <param name="targetPath">Path for the music collection</param>
        /// <param name="filePaths">File paths from the user/system</param>
        /// <returns>A list of all (sorted) music files based upon the given files</returns>
        public static List<MusicFile> ReadMusicFiles(string targetPath, params string[] filePaths)
        {
            //Console.WriteLine(filePaths);

            List<MusicFile> musicFiles = new List<MusicFile>();

            foreach(string path in filePaths)
            {
                FileAttributes attr = File.GetAttributes(path);
                if(attr.HasFlag(FileAttributes.Directory))
                {
                    DirectoryInfo info = new DirectoryInfo(path);
                    foreach(FileInfo file in info.EnumerateFiles())
                    {
                        CheckPath(file.FullName, musicFiles);
                    }
                }
                else
                {
                    CheckPath(path, musicFiles);
                }
            }
            
            return SortFiles(targetPath, musicFiles.ToArray());
        }

        /// <summary>
        /// This method checks a given file and if it exists and is a music file, adds it to the given list
        /// Note: This uses the MusicFile constructor and thus will also imported the ID3 tags of a valid file
        /// </summary>
        /// <param name="filePath">File to be checked</param>
        /// <param name="otherMusicFiles">List of already checked and imported music files</param>
        private static void CheckPath(string filePath, List<MusicFile> otherMusicFiles)
        {
            FileInfo info = new FileInfo(filePath);
            if (info.Exists && CheckExtension(info.Extension))
            {
                otherMusicFiles.Add(new MusicFile(filePath));
            }
        } 

        /// <summary>
        /// Checks whether the given extension matches any of the valid music file extensions for this program
        /// </summary>
        /// <param name="extension">Extension from a file</param>
        /// <returns>True: This program can handle the file, False: This file cannot be handled here</returns>
        private static bool CheckExtension(string extension)
        {
            return extension.Equals(".mp3") || extension.Equals(".ogg");
        }

        #region Sorting

        /// <summary>
        /// This method sorts the given music files into the collection at the given root folder.
        /// Note: This includes checking for albums, artists, parent folders etc.
        /// </summary>
        /// <param name="targetFolder">Root folder of the music collection</param>
        /// <param name="unsortedFiles">Music files to be sorted</param>
        /// <returns>A list of music files sorted into the collection</returns>
        public static List<MusicFile> SortFiles(string targetFolder, params MusicFile[] unsortedFiles)
        {
            List<MusicFile> sortedFiles = new List<MusicFile>();

            Dictionary<string, AlbumInfo> albumInfos = new Dictionary<string, AlbumInfo>();

            // Group in albums and check how many songs are in each album
            foreach(MusicFile file in unsortedFiles)
            {
                if(file.Album != null)
                {
                    if(albumInfos.ContainsKey(file.Album))
                    {
                        AlbumInfo info = albumInfos[file.Album];
                        info.SongCount++;
                        if(!info.IsVarious && !info.Artist.Equals(file.Artist))
                        {
                            info.IsVarious = true;
                        }

                        if(info.MaxDisc <= file.DiscNr)
                        {
                            info.MaxDisc = file.DiscNr;
                        }

                        if(info.MaxTrack <= file.TrackNr)
                        {
                            info.MaxTrack = file.TrackNr;
                        }
                    }
                    else
                    {
                        albumInfos.Add(file.Album, new AlbumInfo(file.Artist, file.DiscNr, file.TrackNr));
                    }
                }
            }

            Dictionary<string, string> parentFolder = new Dictionary<string, string>();

            foreach(MusicFile file in unsortedFiles)
            {
                if(file.IsValid())
                {
                    if (file.Album != null)
                    {
                        if (albumInfos.ContainsKey(file.Album))
                        {
                            file.HasVariousArtists = albumInfos[file.Album].IsVarious;
                            file.MaxDiscNr = albumInfos[file.Album].MaxDisc;
                            file.MaxTrackNr = albumInfos[file.Album].MaxTrack;
                        }

                        bool isPodcast = CheckForPodcast(file);
                        if (albumInfos.ContainsKey(file.Album) && (albumInfos[file.Album].SongCount >= MINIMUM_ALBUM_SONG_NUMBER || isPodcast))
                        {
                            if(isPodcast)
                            {
                                file.Folder = Folders.PODCASTS;
                            }
                            else if (CheckForSoundtrack(file))
                            {
                                file.Folder = Folders.FILMMUSIK;
                            }
                            else
                            {
                                file.Folder = Folders.ALBUM;
                            }

                            if (parentFolder.ContainsKey(file.Album))
                            {
                                file.AlbumParentFolder = parentFolder[file.Album];
                            }
                            else
                            {
                                file.AlbumParentFolder = CheckParentFolder(albumInfos[file.Album].Artist, file.HasVariousArtists, file.Album, file.Folder, targetFolder);
                                parentFolder.Add(file.Album, file.AlbumParentFolder);
                            }
                        }
                        else
                        {
                            file.Folder = Folders.LIEDER;
                        }
                    }
                    else
                    {
                        file.Folder = Folders.LIEDER;
                    }

                    sortedFiles.Add(file);
                }                
            }

            return sortedFiles;
        }

        /// <summary>
        /// Returns whether this file should be sorted into soundtracks instead of albums
        /// </summary>
        /// <param name="file">File to be checked</param>
        /// <returns>True: Should be a soundtrack, False: Not a soundtrack</returns>
        private static bool CheckForSoundtrack(MusicFile file)
        {
            return file.Genre != null && (file.Genre.Contains("Soundtrack") || file.Genre.Contains("Showtune") || file.Genre.Contains("Musical"));
        }

        /// <summary>
        /// Returns whether this file should be sorted into podcasts instead of albums
        /// </summary>
        /// <param name="file">File to be checked</param>
        /// <returns>True: Should be a podcast, False: Not a podcast</returns>
        private static bool CheckForPodcast(MusicFile file)
        {
            return file.Genre != null && (file.Genre.Contains("Podcast") || file.Genre.Contains("Audiobook") || file.Genre.Contains("Speech"));
        }

        /// <summary>
        /// This method checks whether a potential parent folder for the album already exists in the music collection or not.
        /// </summary>
        /// <param name="artist">Artist of the Album</param>
        /// <param name="various">Is this a various artists album (True) or a single artist (False)</param>
        /// <param name="album">Album name</param>
        /// <param name="folder">Folder the album was sorted into</param>
        /// <param name="targetRoot">Root of the music collection</param>
        /// <returns>The potential parent folder for the album (empty string if no parent was found)</returns>
        private static string CheckParentFolder(string artist, bool various, string album, Folders folder, string targetRoot)
        {
            string mainPath = GetPath(targetRoot, folder);

            if (various)
            {
                string[] parts = album.Split(' ');
                StringBuilder builder = new StringBuilder();

                for (int i = 1; i < parts.Length; i++)
                {
                    builder.Clear();

                    for (int j = 0; j < parts.Length - i; j++)
                    {
                        builder.Append(parts[j]);
                        if (j < parts.Length - 1 - i)
                        {
                            builder.Append(" ");
                        }
                    }

                    if (System.IO.Directory.Exists(Path.Combine(mainPath, builder.ToString())))
                    {
                        return builder.ToString();
                    }
                }
            }
            else if (System.IO.Directory.Exists(Path.Combine(mainPath, artist)))
            {
                return artist;
            }

            return "";
        }

        #endregion

        /// <summary>
        /// Resorts the given music files into the new folder within the music collection given by mainFolder
        /// </summary>
        /// <param name="oldFiles">Files to be resorted</param>
        /// <param name="mainFolder">Root folder of the music collection</param>
        /// <param name="newFolder">New folder the files should now be in</param>
        /// <returns>A list of resorted files</returns>
        public static List<MusicFile> RegroupFiles(List<MusicFile> oldFiles, string mainFolder, Folders newFolder)
        {
            List<MusicFile> newList = new List<MusicFile>();

            if(oldFiles.Count != 0)
            {
                MusicFile first = oldFiles[0];
                string newParent = CheckParentFolder(first.Artist, first.HasVariousArtists, first.Album, newFolder, mainFolder);

                foreach(MusicFile file in oldFiles)
                {
                    file.AlbumParentFolder = newParent;
                    file.Folder = newFolder;
                    newList.Add(file);
                }
            }

            return newList;
        }

        /// <summary>
        /// This method alters the parent folder and album folder name of the given music files (all should be in one album). This method is used to allow users to override the default sorting.
        /// </summary>
        /// <param name="files">Files that will be altered</param>
        /// <param name="overrideParent">Should the parent folder be altered?</param>
        /// <param name="parentFolder">New name of the parent folder</param>
        /// <param name="overrideAlbum">Should the album name be altered? (Only affects the folder name, not the tag!)</param>
        /// <param name="albumFolder">New name of the album (Only affects the folder name, not the tag!)</param>
        /// <returns></returns>
        public static List<MusicFile> AlterParent(List<MusicFile> files, bool overrideParent, string parentFolder, bool overrideAlbum, string albumFolder)
        {
            foreach(MusicFile file in files)
            {
                if(overrideAlbum && albumFolder != null && albumFolder.Length > 0)
                {
                    file.AlternateAlbumFolder = albumFolder;
                }
                else
                {
                    file.AlternateAlbumFolder = null;
                }

                if(overrideParent && parentFolder != null && parentFolder.Length > 0)
                {
                    file.AlternateParentFolder = parentFolder;
                }
                else
                {
                    file.AlternateParentFolder = null;
                }
            }

            return files;
        }
    }

    /// <summary>
    /// This class contains all necessary info for an album, but not the music files itself!
    /// This class is used for the sorting of the music files.
    /// </summary>
    public class AlbumInfo
    {
        /// <summary>
        /// How many songs are within the album?
        /// </summary>
        public int SongCount { get; internal set; }

        /// <summary>
        /// How many discs are in the album?
        /// </summary>
        public uint MaxDisc { get; internal set; }

        /// <summary>
        /// What is the highest track number on one disc of the album?
        /// </summary>
        public uint MaxTrack { get; internal set; }

        /// <summary>
        /// Who is the artist of the album?
        /// </summary>
        public string Artist { get; internal set; }

        /// <summary>
        /// Was the album recored by various artists?
        /// </summary>
        public bool IsVarious { get; internal set; }

        /// <summary>
        /// Creates a new AlbumInfo
        /// </summary>
        /// <param name="artist">Artist of the album</param>
        /// <param name="discNr">Maximum disc number</param>
        /// <param name="trackNr">Maxmimum track number</param>
        public AlbumInfo(string artist, uint discNr, uint trackNr)
        {
            this.Artist = artist;
            IsVarious = false;
            SongCount = 1;
            MaxDisc = discNr;
            MaxTrack = trackNr;
        }
    }

    #endregion

}
